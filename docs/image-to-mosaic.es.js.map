{"version":3,"file":"image-to-mosaic.es.js","sources":["../src/utils/dom.ts","../src/utils/density.ts","../src/utils/math.ts","../src/patterns/base.ts","../src/patterns/grid.ts","../src/patterns/brick.ts","../src/patterns/diamond.ts","../src/patterns/strips.ts","../src/patterns/voronoi.ts","../src/patterns/puzzle.ts","../src/patterns/index.ts","../src/delays/sequential.ts","../src/delays/random.ts","../src/delays/center.ts","../src/delays/spiral.ts","../src/delays/index.ts","../src/interactions/hover.ts","../src/interactions/drag.ts","../src/styles.ts","../src/mosaic.ts","../src/mosaic-element.ts","../src/animations/fade.ts","../src/animations/scale.ts","../src/animations/flip.ts","../src/animations/slide.ts","../src/animations/scatter.ts","../src/animations/index.ts"],"sourcesContent":["/**\n * Resolve a target to an HTMLElement\n */\nexport function resolveTarget(target: string | HTMLElement): HTMLElement {\n  if (typeof target === 'string') {\n    const element = document.querySelector(target);\n    if (!element) {\n      throw new Error(`Target element not found: ${target}`);\n    }\n    return element as HTMLElement;\n  }\n  return target;\n}\n\n/**\n * Create an element with styles\n */\nexport function createElement(\n  tag: string,\n  styles: Record<string, string> = {},\n  className?: string\n): HTMLElement {\n  const element = document.createElement(tag);\n  applyStyles(element, styles);\n  if (className) {\n    element.className = className;\n  }\n  return element;\n}\n\n/**\n * Apply styles to an element\n */\nexport function applyStyles(element: HTMLElement, styles: Record<string, string>): void {\n  Object.entries(styles).forEach(([property, value]) => {\n    element.style.setProperty(property, value);\n  });\n}\n\n/**\n * Remove all children from an element\n */\nexport function clearElement(element: HTMLElement): void {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n}\n\n/**\n * Preload an image and return its natural dimensions\n */\nexport function preloadImage(src: string): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      resolve({\n        width: img.naturalWidth,\n        height: img.naturalHeight,\n      });\n    };\n    img.onerror = () => {\n      reject(new Error(`Failed to load image: ${src}`));\n    };\n    img.src = src;\n  });\n}\n\n/**\n * Get computed dimensions of an element\n */\nexport function getElementDimensions(element: HTMLElement): { width: number; height: number } {\n  const rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/**\n * Debounce a function\n */\nexport function debounce<T extends (...args: unknown[]) => void>(\n  fn: T,\n  delay: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: ReturnType<typeof setTimeout>;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n}\n\n/**\n * Request animation frame wrapper with fallback\n */\nexport function nextFrame(): Promise<void> {\n  return new Promise((resolve) => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        resolve();\n      });\n    });\n  });\n}\n","import type { GridDimensions } from '../types';\n\n/**\n * Default minimum tiles (2×2 grid)\n */\nconst MIN_TILES = 4;\n\n/**\n * Convert density value (1-100) to grid dimensions\n * Maintains aspect ratio of the container\n */\nexport function densityToGrid(\n  density: number,\n  containerWidth: number,\n  containerHeight: number,\n  maxTiles: number,\n  gap: number\n): GridDimensions {\n  // Clamp density to valid range\n  const clampedDensity = Math.max(1, Math.min(100, density));\n\n  // Calculate target tile count based on density\n  // Use exponential scaling for more intuitive feel\n  const normalizedDensity = clampedDensity / 100;\n  const targetTiles = Math.round(\n    MIN_TILES + Math.pow(normalizedDensity, 1.5) * (maxTiles - MIN_TILES)\n  );\n\n  // Calculate aspect ratio\n  const aspectRatio = containerWidth / containerHeight;\n\n  // Calculate columns and rows maintaining aspect ratio\n  // cols / rows ≈ aspectRatio\n  // cols * rows ≈ targetTiles\n  // Therefore: cols ≈ sqrt(targetTiles * aspectRatio)\n  let cols = Math.round(Math.sqrt(targetTiles * aspectRatio));\n  let rows = Math.round(cols / aspectRatio);\n\n  // Ensure minimum of 2×2\n  cols = Math.max(2, cols);\n  rows = Math.max(2, rows);\n\n  // Recalculate if we exceed maxTiles\n  while (cols * rows > maxTiles) {\n    if (cols > rows) {\n      cols--;\n    } else {\n      rows--;\n    }\n  }\n\n  // Calculate tile dimensions accounting for gaps\n  const totalGapWidth = gap * (cols - 1);\n  const totalGapHeight = gap * (rows - 1);\n  const tileWidth = (containerWidth - totalGapWidth) / cols;\n  const tileHeight = (containerHeight - totalGapHeight) / rows;\n\n  return {\n    cols,\n    rows,\n    tileWidth,\n    tileHeight,\n  };\n}\n\n/**\n * Calculate the optimal density for a given number of columns\n */\nexport function columnsToApproxDensity(\n  cols: number,\n  containerWidth: number,\n  containerHeight: number,\n  maxTiles: number\n): number {\n  const aspectRatio = containerWidth / containerHeight;\n  const rows = Math.round(cols / aspectRatio);\n  const tiles = cols * rows;\n\n  // Reverse the density calculation\n  const normalizedTiles = (tiles - MIN_TILES) / (maxTiles - MIN_TILES);\n  const density = Math.pow(normalizedTiles, 1 / 1.5) * 100;\n\n  return Math.max(1, Math.min(100, Math.round(density)));\n}\n","/**\n * Clamp a value between min and max\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Linear interpolation between two values\n */\nexport function lerp(start: number, end: number, t: number): number {\n  return start + (end - start) * t;\n}\n\n/**\n * Calculate distance between two points\n */\nexport function distance(x1: number, y1: number, x2: number, y2: number): number {\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\n\n/**\n * Calculate the center point of a grid\n */\nexport function gridCenter(cols: number, rows: number): { x: number; y: number } {\n  return {\n    x: (cols - 1) / 2,\n    y: (rows - 1) / 2,\n  };\n}\n\n/**\n * Shuffle an array in place (Fisher-Yates)\n */\nexport function shuffleArray<T>(array: T[]): T[] {\n  const result = [...array];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}\n\n/**\n * Generate a random number between min and max\n */\nexport function random(min: number, max: number): number {\n  return min + Math.random() * (max - min);\n}\n\n/**\n * Convert degrees to radians\n */\nexport function degToRad(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n/**\n * Convert radians to degrees\n */\nexport function radToDeg(radians: number): number {\n  return radians * (180 / Math.PI);\n}\n\n/**\n * Calculate spiral order for tiles (used for spiral delay mode)\n * Returns an array of indices in spiral order from center outward\n */\nexport function spiralOrder(cols: number, rows: number): number[] {\n  const result: number[] = [];\n  const matrix: number[][] = [];\n\n  // Create matrix with tile indices\n  for (let r = 0; r < rows; r++) {\n    matrix[r] = [];\n    for (let c = 0; c < cols; c++) {\n      matrix[r][c] = r * cols + c;\n    }\n  }\n\n  // Find center\n  const centerRow = Math.floor(rows / 2);\n  const centerCol = Math.floor(cols / 2);\n\n  // Spiral outward from center\n  const visited = new Set<string>();\n  const directions = [\n    [0, 1],   // right\n    [1, 0],   // down\n    [0, -1],  // left\n    [-1, 0],  // up\n  ];\n\n  let r = centerRow;\n  let c = centerCol;\n  let dirIndex = 0;\n  let steps = 1;\n  let stepsTaken = 0;\n  let turnsAtCurrentSteps = 0;\n\n  while (result.length < cols * rows) {\n    const key = `${r},${c}`;\n    if (r >= 0 && r < rows && c >= 0 && c < cols && !visited.has(key)) {\n      visited.add(key);\n      result.push(matrix[r][c]);\n    }\n\n    // Move in current direction\n    r += directions[dirIndex][0];\n    c += directions[dirIndex][1];\n    stepsTaken++;\n\n    // Check if we need to turn\n    if (stepsTaken === steps) {\n      stepsTaken = 0;\n      dirIndex = (dirIndex + 1) % 4;\n      turnsAtCurrentSteps++;\n\n      // Increase steps after every 2 turns\n      if (turnsAtCurrentSteps === 2) {\n        turnsAtCurrentSteps = 0;\n        steps++;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Calculate angle from center for a given position\n */\nexport function angleFromCenter(\n  col: number,\n  row: number,\n  centerCol: number,\n  centerRow: number\n): number {\n  return Math.atan2(row - centerRow, col - centerCol);\n}\n","import type { Pattern, PatternType, TileData } from '../types';\n\n/**\n * Base class for mosaic patterns\n * Provides common functionality and defines the pattern interface\n */\nexport abstract class BasePattern implements Pattern {\n  abstract name: PatternType;\n\n  /**\n   * Sanitize URL to prevent CSS injection attacks\n   * Validates and escapes URLs before use in background-image\n   */\n  protected sanitizeUrl(url: string): string {\n    // Data URLs and blob URLs are safe (generated by browser)\n    if (url.startsWith('data:') || url.startsWith('blob:')) {\n      return url;\n    }\n\n    // Validate HTTP/HTTPS URLs\n    if (url.startsWith('http://') || url.startsWith('https://')) {\n      try {\n        // URL constructor validates the URL format\n        const validatedUrl = new URL(url);\n        return validatedUrl.href;\n      } catch {\n        throw new Error(`Invalid image URL: ${url}`);\n      }\n    }\n\n    // For relative paths, escape characters that could break CSS url()\n    // Escape parentheses, quotes, and backslashes\n    return url.replace(/[()'\"\\\\]/g, '\\\\$&');\n  }\n\n  // Store container dimensions for background calculations\n  protected containerWidth = 0;\n  protected containerHeight = 0;\n\n  /**\n   * Generate tiles for this pattern\n   */\n  abstract generateTiles(\n    containerWidth: number,\n    containerHeight: number,\n    cols: number,\n    rows: number,\n    gap: number\n  ): TileData[];\n\n  /**\n   * Get container styles (can be overridden by patterns)\n   */\n  getContainerStyles(): Record<string, string> {\n    return {\n      position: 'relative',\n      overflow: 'visible',\n    };\n  }\n\n  /**\n   * Get base tile styles\n   * Uses pixel-based positioning for accurate image display\n   */\n  getTileStyles(\n    tile: TileData,\n    imageUrl: string,\n    _cols: number,\n    _rows: number\n  ): Record<string, string> {\n    return {\n      position: 'absolute',\n      left: `${tile.x}px`,\n      top: `${tile.y}px`,\n      width: `${tile.width}px`,\n      height: `${tile.height}px`,\n      'background-image': `url('${this.sanitizeUrl(imageUrl)}')`,\n      // Use container size for background - image covers full mosaic\n      'background-size': `${this.containerWidth}px ${this.containerHeight}px`,\n      // Position background so this tile shows the correct portion\n      'background-position': `-${tile.x}px -${tile.y}px`,\n      'background-repeat': 'no-repeat',\n      ...(tile.clipPath ? { 'clip-path': tile.clipPath } : {}),\n    };\n  }\n\n  /**\n   * Calculate background position for a tile (legacy - now using pixel positioning)\n   */\n  protected calculateBackgroundPosition(\n    col: number,\n    row: number,\n    cols: number,\n    rows: number\n  ): { bgPosX: number; bgPosY: number } {\n    const bgPosX = cols > 1 ? (col / (cols - 1)) * 100 : 0;\n    const bgPosY = rows > 1 ? (row / (rows - 1)) * 100 : 0;\n    return { bgPosX, bgPosY };\n  }\n}\n","import type { TileData, PatternType } from '../types';\nimport { BasePattern } from './base';\n\n/**\n * Standard square grid pattern\n * The most basic and performant pattern\n */\nexport class GridPattern extends BasePattern {\n  name: PatternType = 'grid';\n\n  generateTiles(\n    containerWidth: number,\n    containerHeight: number,\n    cols: number,\n    rows: number,\n    gap: number\n  ): TileData[] {\n    // Store container dimensions for background calculations\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n\n    const tiles: TileData[] = [];\n\n    // Calculate tile dimensions accounting for gaps\n    const totalGapWidth = gap * (cols - 1);\n    const totalGapHeight = gap * (rows - 1);\n    const tileWidth = (containerWidth - totalGapWidth) / cols;\n    const tileHeight = (containerHeight - totalGapHeight) / rows;\n\n    let index = 0;\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = col * (tileWidth + gap);\n        const y = row * (tileHeight + gap);\n\n        tiles.push({\n          index,\n          row,\n          col,\n          x,\n          y,\n          width: tileWidth,\n          height: tileHeight,\n          bgPosX: 0,\n          bgPosY: 0,\n        });\n\n        index++;\n      }\n    }\n\n    return tiles;\n  }\n}\n","import type { TileData, PatternType } from '../types';\nimport { BasePattern } from './base';\n\n/**\n * Brick pattern - offset rows like brickwork\n * Creates a staggered brick-like arrangement\n */\nexport class BrickPattern extends BasePattern {\n  name: PatternType = 'brick';\n\n  generateTiles(\n    containerWidth: number,\n    containerHeight: number,\n    cols: number,\n    rows: number,\n    gap: number\n  ): TileData[] {\n    // Store container dimensions for background calculations\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n\n    const tiles: TileData[] = [];\n\n    // Calculate tile dimensions\n    const totalGapWidth = gap * (cols - 1);\n    const totalGapHeight = gap * (rows - 1);\n    const tileWidth = (containerWidth - totalGapWidth) / cols;\n    const tileHeight = (containerHeight - totalGapHeight) / rows;\n\n    // Offset for odd rows (half tile width + half gap)\n    const offset = (tileWidth + gap) / 2;\n\n    let index = 0;\n    for (let row = 0; row < rows; row++) {\n      const isOddRow = row % 2 === 1;\n      const y = row * (tileHeight + gap);\n\n      // For odd rows, we need cols + 1 tiles to fill the space\n      const tilesInRow = isOddRow ? cols + 1 : cols;\n\n      for (let col = 0; col < tilesInRow; col++) {\n        let x: number;\n        let width: number;\n\n        if (isOddRow) {\n          // Odd rows are offset\n          x = col * (tileWidth + gap) - offset;\n\n          // First tile (partial, starts at edge)\n          if (col === 0) {\n            width = offset - gap / 2;\n            x = 0;\n          }\n          // Last tile (partial, ends at edge)\n          else if (col === tilesInRow - 1) {\n            width = offset - gap / 2;\n            x = containerWidth - width;\n          } else {\n            width = tileWidth;\n          }\n        } else {\n          // Even rows - normal grid\n          x = col * (tileWidth + gap);\n          width = tileWidth;\n        }\n\n        // Skip tiles that would be too small or outside bounds\n        if (width < 1) continue;\n\n        tiles.push({\n          index,\n          row,\n          col,\n          x,\n          y,\n          width,\n          height: tileHeight,\n          bgPosX: 0,\n          bgPosY: 0,\n        });\n\n        index++;\n      }\n    }\n\n    return tiles;\n  }\n}\n","import type { TileData, PatternType } from '../types';\nimport { BasePattern } from './base';\n\n/**\n * Diamond pattern - diamond-shaped tiles arranged in a grid\n * Uses CSS clip-path for diamond shape\n */\nexport class DiamondPattern extends BasePattern {\n  name: PatternType = 'diamond';\n\n  generateTiles(\n    containerWidth: number,\n    containerHeight: number,\n    cols: number,\n    rows: number,\n    gap: number\n  ): TileData[] {\n    // Store container dimensions for background calculations\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n\n    const tiles: TileData[] = [];\n\n    // Calculate tile dimensions accounting for gaps\n    const totalGapWidth = gap * (cols - 1);\n    const totalGapHeight = gap * (rows - 1);\n    const tileWidth = (containerWidth - totalGapWidth) / cols;\n    const tileHeight = (containerHeight - totalGapHeight) / rows;\n\n    let index = 0;\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = col * (tileWidth + gap);\n        const y = row * (tileHeight + gap);\n\n        tiles.push({\n          index,\n          row,\n          col,\n          x,\n          y,\n          width: tileWidth,\n          height: tileHeight,\n          bgPosX: 0,\n          bgPosY: 0,\n          clipPath: 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)',\n        });\n\n        index++;\n      }\n    }\n\n    return tiles;\n  }\n}\n","import type { TileData, PatternType } from '../types';\nimport { BasePattern } from './base';\n\n/**\n * Strips pattern - horizontal or vertical strips\n * Uses cols for vertical strips, rows for horizontal\n */\nexport class StripsPattern extends BasePattern {\n  name: PatternType = 'strips';\n  private orientation: 'horizontal' | 'vertical' = 'horizontal';\n\n  setOrientation(orientation: 'horizontal' | 'vertical'): void {\n    this.orientation = orientation;\n  }\n\n  generateTiles(\n    containerWidth: number,\n    containerHeight: number,\n    cols: number,\n    rows: number,\n    gap: number\n  ): TileData[] {\n    // Store container dimensions for background calculations\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n\n    const tiles: TileData[] = [];\n\n    if (this.orientation === 'horizontal') {\n      // Horizontal strips - use rows count\n      const count = rows;\n      const totalGapHeight = gap * (count - 1);\n      const stripHeight = (containerHeight - totalGapHeight) / count;\n\n      for (let i = 0; i < count; i++) {\n        const y = i * (stripHeight + gap);\n\n        tiles.push({\n          index: i,\n          row: i,\n          col: 0,\n          x: 0,\n          y,\n          width: containerWidth,\n          height: stripHeight,\n          bgPosX: 0,\n          bgPosY: 0,\n        });\n      }\n    } else {\n      // Vertical strips - use cols count\n      const count = cols;\n      const totalGapWidth = gap * (count - 1);\n      const stripWidth = (containerWidth - totalGapWidth) / count;\n\n      for (let i = 0; i < count; i++) {\n        const x = i * (stripWidth + gap);\n\n        tiles.push({\n          index: i,\n          row: 0,\n          col: i,\n          x,\n          y: 0,\n          width: stripWidth,\n          height: containerHeight,\n          bgPosX: 0,\n          bgPosY: 0,\n        });\n      }\n    }\n\n    return tiles;\n  }\n}\n","import type { TileData, PatternType } from '../types';\nimport { BasePattern } from './base';\n\n/**\n * Voronoi pattern - organic irregular cells\n * Uses a simple Voronoi-like algorithm to create irregular polygons\n */\nexport class VoronoiPattern extends BasePattern {\n  name: PatternType = 'voronoi';\n\n  generateTiles(\n    containerWidth: number,\n    containerHeight: number,\n    cols: number,\n    rows: number,\n    gap: number\n  ): TileData[] {\n    // Store container dimensions for background calculations\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n\n    const tiles: TileData[] = [];\n    const numPoints = cols * rows;\n\n    // Generate random seed points with some jitter from grid positions\n    const points: { x: number; y: number }[] = [];\n    const cellWidth = containerWidth / cols;\n    const cellHeight = containerHeight / rows;\n\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        // Add jitter to grid positions\n        const jitterX = (Math.random() - 0.5) * cellWidth * 0.6;\n        const jitterY = (Math.random() - 0.5) * cellHeight * 0.6;\n\n        points.push({\n          x: (col + 0.5) * cellWidth + jitterX,\n          y: (row + 0.5) * cellHeight + jitterY,\n        });\n      }\n    }\n\n    // For each point, calculate its Voronoi cell\n    for (let i = 0; i < numPoints; i++) {\n      const point = points[i];\n      const polygon = this.computeVoronoiCell(\n        point,\n        points,\n        containerWidth,\n        containerHeight,\n        gap\n      );\n\n      if (polygon.length < 3) continue;\n\n      // Calculate bounding box\n      const xs = polygon.map((p) => p.x);\n      const ys = polygon.map((p) => p.y);\n      const minX = Math.max(0, Math.min(...xs));\n      const maxX = Math.min(containerWidth, Math.max(...xs));\n      const minY = Math.max(0, Math.min(...ys));\n      const maxY = Math.min(containerHeight, Math.max(...ys));\n\n      const width = maxX - minX;\n      const height = maxY - minY;\n\n      if (width <= 0 || height <= 0) continue;\n\n      // Create clip path relative to bounding box\n      const clipPoints = polygon.map((p) => {\n        const x = ((p.x - minX) / width) * 100;\n        const y = ((p.y - minY) / height) * 100;\n        return `${x}% ${y}%`;\n      });\n\n      const bgPosX = (point.x / containerWidth) * 100;\n      const bgPosY = (point.y / containerHeight) * 100;\n\n      tiles.push({\n        index: i,\n        row: Math.floor(i / cols),\n        col: i % cols,\n        x: minX,\n        y: minY,\n        width,\n        height,\n        bgPosX,\n        bgPosY,\n        clipPath: `polygon(${clipPoints.join(', ')})`,\n      });\n    }\n\n    return tiles;\n  }\n\n  private computeVoronoiCell(\n    center: { x: number; y: number },\n    allPoints: { x: number; y: number }[],\n    width: number,\n    height: number,\n    gap: number\n  ): { x: number; y: number }[] {\n    // Start with container bounds\n    let polygon: { x: number; y: number }[] = [\n      { x: 0, y: 0 },\n      { x: width, y: 0 },\n      { x: width, y: height },\n      { x: 0, y: height },\n    ];\n\n    // Clip polygon by perpendicular bisector with each other point\n    for (const other of allPoints) {\n      if (other === center) continue;\n\n      // Midpoint and perpendicular direction\n      const midX = (center.x + other.x) / 2;\n      const midY = (center.y + other.y) / 2;\n\n      // Direction from center to other\n      const dx = other.x - center.x;\n      const dy = other.y - center.y;\n\n      // Clip polygon to keep only the side containing center\n      polygon = this.clipPolygon(polygon, midX, midY, dx, dy, gap / 2);\n\n      if (polygon.length < 3) break;\n    }\n\n    return polygon;\n  }\n\n  private clipPolygon(\n    polygon: { x: number; y: number }[],\n    lineX: number,\n    lineY: number,\n    normalX: number,\n    normalY: number,\n    offset: number\n  ): { x: number; y: number }[] {\n    if (polygon.length < 3) return [];\n\n    // Offset the line slightly for gap\n    const len = Math.sqrt(normalX * normalX + normalY * normalY);\n    const nx = normalX / len;\n    const ny = normalY / len;\n    const offsetLineX = lineX - nx * offset;\n    const offsetLineY = lineY - ny * offset;\n\n    const result: { x: number; y: number }[] = [];\n\n    for (let i = 0; i < polygon.length; i++) {\n      const current = polygon[i];\n      const next = polygon[(i + 1) % polygon.length];\n\n      const currentSide = this.sideOfLine(current, offsetLineX, offsetLineY, nx, ny);\n      const nextSide = this.sideOfLine(next, offsetLineX, offsetLineY, nx, ny);\n\n      if (currentSide <= 0) {\n        result.push(current);\n      }\n\n      if ((currentSide < 0 && nextSide > 0) || (currentSide > 0 && nextSide < 0)) {\n        const intersection = this.lineIntersection(\n          current,\n          next,\n          offsetLineX,\n          offsetLineY,\n          nx,\n          ny\n        );\n        if (intersection) {\n          result.push(intersection);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private sideOfLine(\n    point: { x: number; y: number },\n    lineX: number,\n    lineY: number,\n    normalX: number,\n    normalY: number\n  ): number {\n    return (point.x - lineX) * normalX + (point.y - lineY) * normalY;\n  }\n\n  private lineIntersection(\n    p1: { x: number; y: number },\n    p2: { x: number; y: number },\n    lineX: number,\n    lineY: number,\n    normalX: number,\n    normalY: number\n  ): { x: number; y: number } | null {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    const denom = dx * normalX + dy * normalY;\n\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((lineX - p1.x) * normalX + (lineY - p1.y) * normalY) / denom;\n\n    return {\n      x: p1.x + t * dx,\n      y: p1.y + t * dy,\n    };\n  }\n\n  getTileStyles(\n    tile: TileData,\n    imageUrl: string,\n    _cols: number,\n    _rows: number\n  ): Record<string, string> {\n    return {\n      position: 'absolute',\n      left: `${tile.x}px`,\n      top: `${tile.y}px`,\n      width: `${tile.width}px`,\n      height: `${tile.height}px`,\n      'background-image': `url('${this.sanitizeUrl(imageUrl)}')`,\n      'background-size': `${this.containerWidth}px ${this.containerHeight}px`,\n      'background-position': `-${tile.x}px -${tile.y}px`,\n      'background-repeat': 'no-repeat',\n      'clip-path': tile.clipPath || '',\n    };\n  }\n}\n","import type { TileData, PatternType } from '../types';\nimport { BasePattern } from './base';\n\n/**\n * Puzzle pattern - jigsaw-like interlocking pieces with smooth bezier curves\n * Uses clip-path: path() with SVG cubic bezier curves for authentic jigsaw tabs\n */\nexport class PuzzlePattern extends BasePattern {\n  name: PatternType = 'puzzle';\n\n  // Store bump directions for edge consistency\n  private horizontalBumps: boolean[][] = [];\n  private verticalBumps: boolean[][] = [];\n  private tabSize = 0;\n  private gap = 0;\n\n  generateTiles(\n    containerWidth: number,\n    containerHeight: number,\n    cols: number,\n    rows: number,\n    gap: number\n  ): TileData[] {\n    this.containerWidth = containerWidth;\n    this.containerHeight = containerHeight;\n    this.gap = gap;\n\n    const tiles: TileData[] = [];\n\n    const baseTileWidth = containerWidth / cols;\n    const baseTileHeight = containerHeight / rows;\n\n    // Tab size proportional to tile size (18% of smaller dimension)\n    this.tabSize = Math.min(baseTileWidth, baseTileHeight) * 0.18;\n\n    // Pre-generate random bump directions for all internal edges\n    // horizontalBumps[row][col] = true means right edge of tile[row][col] has outward tab\n    this.horizontalBumps = [];\n    for (let row = 0; row < rows; row++) {\n      this.horizontalBumps[row] = [];\n      for (let col = 0; col < cols - 1; col++) {\n        this.horizontalBumps[row][col] = Math.random() > 0.5;\n      }\n    }\n\n    // verticalBumps[row][col] = true means bottom edge of tile[row][col] has outward tab\n    this.verticalBumps = [];\n    for (let row = 0; row < rows - 1; row++) {\n      this.verticalBumps[row] = [];\n      for (let col = 0; col < cols; col++) {\n        this.verticalBumps[row][col] = Math.random() > 0.5;\n      }\n    }\n\n    let index = 0;\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        const baseX = col * baseTileWidth;\n        const baseY = row * baseTileHeight;\n\n        // Determine edge types for this tile\n        // 'tab' = protrudes outward, 'hole' = indents inward, 'flat' = straight edge\n        const edges = {\n          top: row === 0 ? 'flat' : (this.verticalBumps[row - 1][col] ? 'hole' : 'tab'),\n          right: col === cols - 1 ? 'flat' : (this.horizontalBumps[row][col] ? 'tab' : 'hole'),\n          bottom: row === rows - 1 ? 'flat' : (this.verticalBumps[row][col] ? 'tab' : 'hole'),\n          left: col === 0 ? 'flat' : (this.horizontalBumps[row][col - 1] ? 'hole' : 'tab'),\n        };\n\n        // Expanded bounds to accommodate tabs\n        const expandedX = baseX - this.tabSize;\n        const expandedY = baseY - this.tabSize;\n        const expandedWidth = baseTileWidth + this.tabSize * 2;\n        const expandedHeight = baseTileHeight + this.tabSize * 2;\n\n        // Generate the SVG path for this puzzle piece\n        const clipPath = this.generatePuzzlePath(\n          baseTileWidth,\n          baseTileHeight,\n          this.tabSize,\n          edges,\n          this.gap\n        );\n\n        tiles.push({\n          index,\n          row,\n          col,\n          x: expandedX,\n          y: expandedY,\n          width: expandedWidth,\n          height: expandedHeight,\n          bgPosX: 0,\n          bgPosY: 0,\n          clipPath,\n        });\n\n        index++;\n      }\n    }\n\n    return tiles;\n  }\n\n  /**\n   * Generate SVG path for a puzzle piece with bezier curve tabs\n   */\n  private generatePuzzlePath(\n    tileWidth: number,\n    tileHeight: number,\n    tabSize: number,\n    edges: { top: string; right: string; bottom: string; left: string },\n    gap: number\n  ): string {\n    // Coordinates relative to expanded bounds\n    // The actual tile content starts at (tabSize, tabSize)\n    // Inset by half the gap on each side to create separation\n    const inset = gap / 2;\n    const left = tabSize + inset;\n    const top = tabSize + inset;\n    const right = tabSize + tileWidth - inset;\n    const bottom = tabSize + tileHeight - inset;\n\n    const pathParts: string[] = [];\n\n    // Start at top-left corner\n    pathParts.push(`M ${left} ${top}`);\n\n    // Effective tab size reduced by gap inset\n    const effectiveTabSize = Math.max(tabSize - inset, tabSize * 0.5);\n\n    // Top edge (left to right)\n    pathParts.push(this.generateEdgePath(\n      left, top, right, top,\n      edges.top, 'horizontal', 'up', effectiveTabSize\n    ));\n\n    // Right edge (top to bottom)\n    pathParts.push(this.generateEdgePath(\n      right, top, right, bottom,\n      edges.right, 'vertical', 'right', effectiveTabSize\n    ));\n\n    // Bottom edge (right to left)\n    pathParts.push(this.generateEdgePath(\n      right, bottom, left, bottom,\n      edges.bottom, 'horizontal', 'down', effectiveTabSize\n    ));\n\n    // Left edge (bottom to top)\n    pathParts.push(this.generateEdgePath(\n      left, bottom, left, top,\n      edges.left, 'vertical', 'left', effectiveTabSize\n    ));\n\n    pathParts.push('Z');\n\n    return `path('${pathParts.join(' ')}')`;\n  }\n\n  /**\n   * Generate path for a single edge with optional tab or hole\n   */\n  private generateEdgePath(\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    edgeType: string,\n    orientation: 'horizontal' | 'vertical',\n    outwardDir: 'up' | 'down' | 'left' | 'right',\n    tabSize: number\n  ): string {\n    if (edgeType === 'flat') {\n      return `L ${endX} ${endY}`;\n    }\n\n    const isTab = edgeType === 'tab';\n    // For holes, we go opposite direction\n    const direction = isTab ? outwardDir : this.oppositeDir(outwardDir);\n\n    // Calculate the tab/hole path\n    const midX = (startX + endX) / 2;\n    const midY = (startY + endY) / 2;\n\n    // Tab dimensions\n    const tabWidth = tabSize * 0.8;  // Width of the neck\n    const tabDepth = tabSize * 0.95; // How far the tab extends\n\n    if (orientation === 'horizontal') {\n      // Edge goes horizontally\n      const goingRight = endX > startX;\n      const sign = goingRight ? 1 : -1;\n\n      const neckStart = midX - sign * tabWidth;\n      const neckEnd = midX + sign * tabWidth;\n\n      const perpSign = direction === 'up' ? -1 : 1;\n      const y = startY;\n      const peakY = y + perpSign * tabDepth;\n      const neckY = y + perpSign * (tabDepth * 0.35);\n\n      // Classic jigsaw shape using cubic beziers\n      return `L ${neckStart} ${y} ` +\n             `C ${neckStart} ${neckY}, ${midX - sign * tabWidth * 1.3} ${peakY}, ${midX} ${peakY} ` +\n             `C ${midX + sign * tabWidth * 1.3} ${peakY}, ${neckEnd} ${neckY}, ${neckEnd} ${y} ` +\n             `L ${endX} ${endY}`;\n    } else {\n      // Edge goes vertically\n      const goingDown = endY > startY;\n      const sign = goingDown ? 1 : -1;\n\n      const neckStart = midY - sign * tabWidth;\n      const neckEnd = midY + sign * tabWidth;\n\n      const perpSign = direction === 'right' ? 1 : -1;\n      const x = startX;\n      const peakX = x + perpSign * tabDepth;\n      const neckX = x + perpSign * (tabDepth * 0.35);\n\n      // Classic jigsaw shape using cubic beziers\n      return `L ${x} ${neckStart} ` +\n             `C ${neckX} ${neckStart}, ${peakX} ${midY - sign * tabWidth * 1.3}, ${peakX} ${midY} ` +\n             `C ${peakX} ${midY + sign * tabWidth * 1.3}, ${neckX} ${neckEnd}, ${x} ${neckEnd} ` +\n             `L ${endX} ${endY}`;\n    }\n  }\n\n  private oppositeDir(dir: 'up' | 'down' | 'left' | 'right'): 'up' | 'down' | 'left' | 'right' {\n    switch (dir) {\n      case 'up': return 'down';\n      case 'down': return 'up';\n      case 'left': return 'right';\n      case 'right': return 'left';\n    }\n  }\n\n  getTileStyles(\n    tile: TileData,\n    imageUrl: string,\n    _cols: number,\n    _rows: number\n  ): Record<string, string> {\n    // Background position: we need to show the correct portion of the image\n    // tile.x and tile.y are the expanded positions (can be negative)\n    // The math: -tile.x positions the image correctly\n    // But we need to handle negative tile.x properly\n    const bgPosX = -tile.x;\n    const bgPosY = -tile.y;\n\n    return {\n      position: 'absolute',\n      left: `${tile.x}px`,\n      top: `${tile.y}px`,\n      width: `${tile.width}px`,\n      height: `${tile.height}px`,\n      'background-image': `url('${this.sanitizeUrl(imageUrl)}')`,\n      'background-size': `${this.containerWidth}px ${this.containerHeight}px`,\n      'background-position': `${bgPosX}px ${bgPosY}px`,\n      'background-repeat': 'no-repeat',\n      'clip-path': tile.clipPath || '',\n      filter: 'drop-shadow(1px 1px 2px rgba(0,0,0,0.3))',\n    };\n  }\n}\n","import type { Pattern, PatternType } from '../types';\nimport { GridPattern } from './grid';\nimport { BrickPattern } from './brick';\nimport { DiamondPattern } from './diamond';\nimport { StripsPattern } from './strips';\nimport { VoronoiPattern } from './voronoi';\nimport { PuzzlePattern } from './puzzle';\n\n/**\n * Pattern registry - maps pattern names to pattern instances\n * V1 Patterns: grid, brick, diamond, strips, voronoi, puzzle\n */\nconst patterns: Map<PatternType, Pattern> = new Map([\n  ['grid', new GridPattern()],\n  ['brick', new BrickPattern()],\n  ['diamond', new DiamondPattern()],\n  ['strips', new StripsPattern()],\n  ['voronoi', new VoronoiPattern()],\n  ['puzzle', new PuzzlePattern()],\n]);\n\n/**\n * Get a pattern by name\n */\nexport function getPattern(name: PatternType): Pattern {\n  const pattern = patterns.get(name);\n  if (!pattern) {\n    console.warn(`Pattern \"${name}\" not found, falling back to grid`);\n    return patterns.get('grid')!;\n  }\n  return pattern;\n}\n\n/**\n * Get all available pattern names\n */\nexport function getPatternNames(): PatternType[] {\n  return Array.from(patterns.keys());\n}\n\n/**\n * Register a custom pattern\n */\nexport function registerPattern(pattern: Pattern): void {\n  patterns.set(pattern.name, pattern);\n}\n\n// Re-export pattern classes for extension\nexport { BasePattern } from './base';\nexport { GridPattern } from './grid';\nexport { BrickPattern } from './brick';\nexport { DiamondPattern } from './diamond';\nexport { StripsPattern } from './strips';\nexport { VoronoiPattern } from './voronoi';\nexport { PuzzlePattern } from './puzzle';\n","import type { DelayCalculator, TileData } from '../types';\n\n/**\n * Sequential delay - tiles animate one after another\n */\nexport class SequentialDelay implements DelayCalculator {\n  calculate(\n    tile: TileData,\n    totalTiles: number,\n    _cols: number,\n    _rows: number,\n    maxDelay: number\n  ): number {\n    return (tile.index / totalTiles) * maxDelay;\n  }\n}\n","import type { DelayCalculator, TileData } from '../types';\n\n/**\n * Random delay - tiles animate with random delays\n */\nexport class RandomDelay implements DelayCalculator {\n  calculate(\n    _tile: TileData,\n    _totalTiles: number,\n    _cols: number,\n    _rows: number,\n    maxDelay: number\n  ): number {\n    return Math.random() * maxDelay;\n  }\n}\n","import type { DelayCalculator, TileData } from '../types';\nimport { distance, gridCenter } from '../utils/math';\n\n/**\n * Center delay - tiles animate from center outward\n */\nexport class CenterDelay implements DelayCalculator {\n  calculate(\n    tile: TileData,\n    _totalTiles: number,\n    cols: number,\n    rows: number,\n    maxDelay: number\n  ): number {\n    const center = gridCenter(cols, rows);\n    const dist = distance(tile.col, tile.row, center.x, center.y);\n    const maxDist = distance(0, 0, center.x, center.y);\n\n    return (dist / maxDist) * maxDelay;\n  }\n}\n","import type { DelayCalculator, TileData } from '../types';\nimport { spiralOrder } from '../utils/math';\n\n/**\n * Spiral delay - tiles animate in a spiral pattern from center\n */\nexport class SpiralDelay implements DelayCalculator {\n  private spiralCache: Map<string, number[]> = new Map();\n\n  calculate(\n    tile: TileData,\n    totalTiles: number,\n    cols: number,\n    rows: number,\n    maxDelay: number\n  ): number {\n    // Cache spiral order for this grid size\n    const cacheKey = `${cols}x${rows}`;\n    let order = this.spiralCache.get(cacheKey);\n\n    if (!order) {\n      order = spiralOrder(cols, rows);\n      this.spiralCache.set(cacheKey, order);\n    }\n\n    // Find position in spiral order\n    const spiralIndex = order.indexOf(tile.index);\n    const normalizedIndex = spiralIndex >= 0 ? spiralIndex : tile.index;\n\n    return (normalizedIndex / totalTiles) * maxDelay;\n  }\n}\n","import type { DelayCalculator, DelayMode } from '../types';\nimport { SequentialDelay } from './sequential';\nimport { RandomDelay } from './random';\nimport { CenterDelay } from './center';\nimport { SpiralDelay } from './spiral';\n\n/**\n * Fixed delay - same delay for all tiles\n */\nclass FixedDelay implements DelayCalculator {\n  constructor(private delay: number) {}\n\n  calculate(): number {\n    return this.delay;\n  }\n}\n\n/**\n * Delay calculator registry\n */\nconst delayCalculators: Map<string, DelayCalculator> = new Map([\n  ['sequential', new SequentialDelay()],\n  ['random', new RandomDelay()],\n  ['center', new CenterDelay()],\n  ['spiral', new SpiralDelay()],\n]);\n\n/**\n * Get a delay calculator by mode\n */\nexport function getDelayCalculator(mode: DelayMode): DelayCalculator {\n  if (typeof mode === 'number') {\n    return new FixedDelay(mode);\n  }\n\n  const calculator = delayCalculators.get(mode);\n  if (!calculator) {\n    console.warn(`Delay mode \"${mode}\" not found, falling back to random`);\n    return delayCalculators.get('random')!;\n  }\n  return calculator;\n}\n\n/**\n * Get all available delay mode names\n */\nexport function getDelayModeNames(): string[] {\n  return Array.from(delayCalculators.keys());\n}\n\n/**\n * Register a custom delay calculator\n */\nexport function registerDelayCalculator(name: string, calculator: DelayCalculator): void {\n  delayCalculators.set(name, calculator);\n}\n\n// Re-export delay classes\nexport { SequentialDelay } from './sequential';\nexport { RandomDelay } from './random';\nexport { CenterDelay } from './center';\nexport { SpiralDelay } from './spiral';\n","import type { HoverConfig } from '../types';\n\n// Store tilt handlers for cleanup\nconst tiltHandlers = new WeakMap<HTMLElement, { move: (e: MouseEvent) => void; leave: () => void }>();\n\n/**\n * Apply hover effect to a tile element using CSS class\n */\nexport function applyHoverEffect(element: HTMLElement, config: HoverConfig): void {\n  const { effect, scale, duration, color } = config;\n\n  if (effect === 'none') return;\n\n  // Set CSS custom properties for scale and duration\n  if (scale !== undefined) {\n    element.style.setProperty('--hover-scale', scale.toString());\n  }\n  if (duration !== undefined) {\n    element.style.setProperty('--hover-duration', `${duration}ms`);\n  }\n\n  // Set glow color if provided\n  if (color && effect === 'glow') {\n    element.style.setProperty('--hover-color', color);\n  }\n\n  // Add the CSS class\n  element.classList.add(`hover-${effect}`);\n\n  // For tilt effect, add dynamic mouse tracking\n  if (effect === 'tilt') {\n    setupTiltTracking(element);\n  }\n}\n\n/**\n * Setup dynamic tilt tracking based on mouse position\n */\nfunction setupTiltTracking(element: HTMLElement): void {\n  const handleMouseMove = (e: MouseEvent) => {\n    const rect = element.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    // Calculate tilt based on mouse position relative to center\n    const centerX = rect.width / 2;\n    const centerY = rect.height / 2;\n\n    // Max tilt of 15 degrees\n    const tiltY = ((x - centerX) / centerX) * 15;\n    const tiltX = ((centerY - y) / centerY) * 15;\n\n    element.style.setProperty('--tilt-x', `${tiltX}deg`);\n    element.style.setProperty('--tilt-y', `${tiltY}deg`);\n  };\n\n  const handleMouseLeave = () => {\n    element.style.setProperty('--tilt-x', '0deg');\n    element.style.setProperty('--tilt-y', '0deg');\n  };\n\n  element.addEventListener('mousemove', handleMouseMove);\n  element.addEventListener('mouseleave', handleMouseLeave);\n\n  // Store handlers for cleanup\n  tiltHandlers.set(element, { move: handleMouseMove, leave: handleMouseLeave });\n}\n\n/**\n * Remove hover effect from an element\n */\nexport function removeHoverEffect(element: HTMLElement): void {\n  // Remove all hover classes\n  element.classList.remove(\n    'hover-lift',\n    'hover-glow',\n    'hover-zoom',\n    'hover-tilt',\n    'hover-flip',\n    'hover-blur',\n    'hover-pop',\n    'hover-spotlight'\n  );\n\n  // Clean up tilt handlers if present\n  const handlers = tiltHandlers.get(element);\n  if (handlers) {\n    element.removeEventListener('mousemove', handlers.move);\n    element.removeEventListener('mouseleave', handlers.leave);\n    tiltHandlers.delete(element);\n  }\n\n  // Reset CSS custom properties\n  element.style.removeProperty('--tilt-x');\n  element.style.removeProperty('--tilt-y');\n  element.style.removeProperty('--hover-color');\n}\n\n/**\n * Apply hover effect to all tiles in a container\n */\nexport function applyHoverToContainer(container: HTMLElement, config: HoverConfig): void {\n  if (config.effect === 'none') return;\n\n  const tiles = container.querySelectorAll('.mosaic-tile');\n  tiles.forEach((tile) => {\n    applyHoverEffect(tile as HTMLElement, config);\n  });\n}\n\n/**\n * Remove hover effects from all tiles in a container\n */\nexport function removeHoverFromContainer(container: HTMLElement): void {\n  const tiles = container.querySelectorAll('.mosaic-tile');\n  tiles.forEach((tile) => {\n    removeHoverEffect(tile as HTMLElement);\n  });\n}\n","import type { TileData } from '../types';\n\n/**\n * Drag state for a container\n */\ninterface DragState {\n  isDragging: boolean;\n  currentTile: TileData | null;\n  currentElement: HTMLElement | null;\n  startX: number;\n  startY: number;\n  originalX: number;\n  originalY: number;\n}\n\n/**\n * WeakMap to store drag handlers for cleanup\n */\nconst dragStates: WeakMap<HTMLElement, DragState> = new WeakMap();\nconst dragHandlers: WeakMap<HTMLElement, {\n  mousedown: (e: MouseEvent) => void;\n  mousemove: (e: MouseEvent) => void;\n  mouseup: (e: MouseEvent) => void;\n  touchstart: (e: TouchEvent) => void;\n  touchmove: (e: TouchEvent) => void;\n  touchend: (e: TouchEvent) => void;\n}> = new WeakMap();\n\n/**\n * Initialize drag and drop for mosaic tiles\n */\nexport function initDraggable(container: HTMLElement, tiles: TileData[]): void {\n  const state: DragState = {\n    isDragging: false,\n    currentTile: null,\n    currentElement: null,\n    startX: 0,\n    startY: 0,\n    originalX: 0,\n    originalY: 0,\n  };\n\n  dragStates.set(container, state);\n\n  const startDrag = (clientX: number, clientY: number, target: HTMLElement) => {\n    if (!target.classList.contains('mosaic-tile')) return false;\n\n    const index = parseInt(target.dataset.index || '-1', 10);\n    const tile = tiles.find((t) => t.index === index);\n    if (!tile || !tile.element) return false;\n\n    state.isDragging = true;\n    state.currentTile = tile;\n    state.currentElement = tile.element;\n    state.startX = clientX;\n    state.startY = clientY;\n    state.originalX = tile.x;\n    state.originalY = tile.y;\n\n    // Bring to front and change cursor\n    tile.element.style.zIndex = '100';\n    tile.element.style.cursor = 'grabbing';\n    tile.element.style.transition = 'none'; // Disable transition during drag\n\n    return true;\n  };\n\n  const moveDrag = (clientX: number, clientY: number) => {\n    if (!state.isDragging || !state.currentElement) return;\n\n    const dx = clientX - state.startX;\n    const dy = clientY - state.startY;\n\n    const newX = state.originalX + dx;\n    const newY = state.originalY + dy;\n\n    state.currentElement.style.left = `${newX}px`;\n    state.currentElement.style.top = `${newY}px`;\n\n    // Update tile data for swap detection\n    if (state.currentTile) {\n      state.currentTile.x = newX;\n      state.currentTile.y = newY;\n    }\n  };\n\n  const endDrag = () => {\n    if (!state.isDragging || !state.currentTile || !state.currentElement) return;\n\n    // Find closest swap target\n    const dropTarget = findClosestTile(state.currentTile, tiles);\n\n    if (dropTarget && dropTarget !== state.currentTile && dropTarget.element) {\n      // Swap positions\n      swapTiles(state.currentTile, dropTarget, state.originalX, state.originalY);\n    } else {\n      // Snap back to original position\n      state.currentElement.style.transition = 'left 200ms ease-out, top 200ms ease-out';\n      state.currentElement.style.left = `${state.originalX}px`;\n      state.currentElement.style.top = `${state.originalY}px`;\n      state.currentTile.x = state.originalX;\n      state.currentTile.y = state.originalY;\n    }\n\n    // Reset styles\n    state.currentElement.style.zIndex = '1';\n    state.currentElement.style.cursor = 'grab';\n\n    state.isDragging = false;\n    state.currentTile = null;\n    state.currentElement = null;\n  };\n\n  const handlers = {\n    mousedown: (e: MouseEvent) => {\n      const target = e.target as HTMLElement;\n      if (startDrag(e.clientX, e.clientY, target)) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    },\n\n    mousemove: (e: MouseEvent) => {\n      if (state.isDragging) {\n        e.preventDefault();\n        moveDrag(e.clientX, e.clientY);\n      }\n    },\n\n    mouseup: (e: MouseEvent) => {\n      if (state.isDragging) {\n        e.preventDefault();\n        endDrag();\n      }\n    },\n\n    touchstart: (e: TouchEvent) => {\n      const touch = e.touches[0];\n      const target = e.target as HTMLElement;\n      if (startDrag(touch.clientX, touch.clientY, target)) {\n        e.preventDefault();\n      }\n    },\n\n    touchmove: (e: TouchEvent) => {\n      if (state.isDragging) {\n        e.preventDefault();\n        const touch = e.touches[0];\n        moveDrag(touch.clientX, touch.clientY);\n      }\n    },\n\n    touchend: (e: TouchEvent) => {\n      if (state.isDragging) {\n        e.preventDefault();\n        endDrag();\n      }\n    },\n  };\n\n  dragHandlers.set(container, handlers);\n\n  // Add event listeners to container for mousedown\n  container.addEventListener('mousedown', handlers.mousedown);\n  container.addEventListener('touchstart', handlers.touchstart, { passive: false });\n\n  // Add mousemove and mouseup to document for drag tracking\n  document.addEventListener('mousemove', handlers.mousemove);\n  document.addEventListener('mouseup', handlers.mouseup);\n  document.addEventListener('touchmove', handlers.touchmove, { passive: false });\n  document.addEventListener('touchend', handlers.touchend);\n\n  // Set initial cursor style for tiles\n  tiles.forEach((tile) => {\n    if (tile.element) {\n      tile.element.style.cursor = 'grab';\n    }\n  });\n}\n\n/**\n * Find the closest tile to swap with\n */\nfunction findClosestTile(\n  dragged: TileData,\n  tiles: TileData[]\n): TileData | null {\n  let closest: TileData | null = null;\n  let minDist = Infinity;\n\n  const dragCenterX = dragged.x + dragged.width / 2;\n  const dragCenterY = dragged.y + dragged.height / 2;\n\n  for (const tile of tiles) {\n    if (tile === dragged) continue;\n\n    const tileCenterX = tile.x + tile.width / 2;\n    const tileCenterY = tile.y + tile.height / 2;\n\n    const dist = Math.sqrt(\n      Math.pow(dragCenterX - tileCenterX, 2) + Math.pow(dragCenterY - tileCenterY, 2)\n    );\n\n    // Only consider tiles within reasonable distance (half the tile size)\n    const threshold = Math.min(dragged.width, dragged.height) * 0.75;\n    if (dist < threshold && dist < minDist) {\n      minDist = dist;\n      closest = tile;\n    }\n  }\n\n  return closest;\n}\n\n/**\n * Swap positions of two tiles\n */\nfunction swapTiles(\n  tile1: TileData,\n  tile2: TileData,\n  tile1OriginalX: number,\n  tile1OriginalY: number\n): void {\n  // Tile1 goes to tile2's position, tile2 goes to tile1's original position\n  const tile2X = tile2.x;\n  const tile2Y = tile2.y;\n\n  // Update tile1 position (goes to tile2's position)\n  tile1.x = tile2X;\n  tile1.y = tile2Y;\n  if (tile1.element) {\n    tile1.element.style.transition = 'left 200ms ease-out, top 200ms ease-out';\n    tile1.element.style.left = `${tile2X}px`;\n    tile1.element.style.top = `${tile2Y}px`;\n  }\n\n  // Update tile2 position (goes to tile1's original position)\n  tile2.x = tile1OriginalX;\n  tile2.y = tile1OriginalY;\n  if (tile2.element) {\n    tile2.element.style.transition = 'left 200ms ease-out, top 200ms ease-out';\n    tile2.element.style.left = `${tile1OriginalX}px`;\n    tile2.element.style.top = `${tile1OriginalY}px`;\n  }\n}\n\n/**\n * Destroy drag and drop for a container\n */\nexport function destroyDraggable(container: HTMLElement): void {\n  const handlers = dragHandlers.get(container);\n  if (handlers) {\n    container.removeEventListener('mousedown', handlers.mousedown);\n    container.removeEventListener('touchstart', handlers.touchstart);\n    document.removeEventListener('mousemove', handlers.mousemove);\n    document.removeEventListener('mouseup', handlers.mouseup);\n    document.removeEventListener('touchmove', handlers.touchmove);\n    document.removeEventListener('touchend', handlers.touchend);\n    dragHandlers.delete(container);\n  }\n\n  dragStates.delete(container);\n}\n","/**\n * CSS styles for mosaic effects\n * All animations and hover effects are CSS-only\n */\n\nlet styleElement: HTMLStyleElement | null = null;\nlet instanceCount = 0;\n\n/**\n * Inject all mosaic styles into the document\n * Uses reference counting to support multiple Mosaic instances\n */\nexport function injectStyles(): void {\n  instanceCount++;\n  if (styleElement) return;\n\n  styleElement = document.createElement('style');\n  styleElement.id = 'mosaic-styles';\n\n  styleElement.textContent = `\n    /* ========== BASE TILE STYLES ========== */\n    .mosaic-tile {\n      position: absolute;\n      background-repeat: no-repeat;\n      transform-origin: center center;\n    }\n\n    /* ========== ANIMATION KEYFRAMES ========== */\n    @keyframes mosaic-fade {\n      from { opacity: 0; }\n      to { opacity: 1; }\n    }\n\n    @keyframes mosaic-scale {\n      from { opacity: 0; transform: scale(0.5); }\n      to { opacity: 1; transform: scale(1); }\n    }\n\n    @keyframes mosaic-flip {\n      from { opacity: 0; transform: perspective(400px) rotateY(90deg); }\n      to { opacity: 1; transform: perspective(400px) rotateY(0deg); }\n    }\n\n    @keyframes mosaic-slide {\n      from { opacity: 0; transform: translateY(30px); }\n      to { opacity: 1; transform: translateY(0); }\n    }\n\n    @keyframes mosaic-scatter {\n      from {\n        opacity: 0;\n        transform: translate(calc((var(--random-x, 0) - 0.5) * 200px), calc((var(--random-y, 0) - 0.5) * 200px)) rotate(calc((var(--random-r, 0) - 0.5) * 90deg));\n      }\n      to {\n        opacity: 1;\n        transform: translate(0, 0) rotate(0deg);\n      }\n    }\n\n    /* ========== ANIMATION CLASSES ========== */\n    .mosaic-tile.animate-none {\n      opacity: 1;\n    }\n\n    /* Completed state - no transform so hover works */\n    .mosaic-tile.animate-complete {\n      opacity: 1;\n    }\n\n    .mosaic-tile.animate-fade {\n      opacity: 0;\n      animation: mosaic-fade var(--animation-duration, 500ms) var(--animation-easing, ease-out) var(--animation-delay, 0ms) forwards;\n    }\n\n    .mosaic-tile.animate-scale {\n      opacity: 0;\n      transform: scale(0.5);\n      animation: mosaic-scale var(--animation-duration, 500ms) var(--animation-easing, ease-out) var(--animation-delay, 0ms) forwards;\n    }\n\n    .mosaic-tile.animate-flip {\n      opacity: 0;\n      transform: perspective(400px) rotateY(90deg);\n      animation: mosaic-flip var(--animation-duration, 500ms) var(--animation-easing, ease-out) var(--animation-delay, 0ms) forwards;\n    }\n\n    .mosaic-tile.animate-slide {\n      opacity: 0;\n      transform: translateY(30px);\n      animation: mosaic-slide var(--animation-duration, 500ms) var(--animation-easing, ease-out) var(--animation-delay, 0ms) forwards;\n    }\n\n    .mosaic-tile.animate-scatter {\n      opacity: 0;\n      animation: mosaic-scatter var(--animation-duration, 500ms) var(--animation-easing, ease-out) var(--animation-delay, 0ms) forwards;\n    }\n\n    /* ========== HOVER EFFECTS ========== */\n\n    /* Lift - rises up with shadow */\n    .mosaic-tile.hover-lift {\n      transition: transform var(--hover-duration, 200ms) ease-out, box-shadow var(--hover-duration, 200ms) ease-out;\n    }\n    .mosaic-tile.hover-lift:hover {\n      transform: translateY(-8px) scale(1.02);\n      box-shadow: 0 12px 30px rgba(0,0,0,0.35);\n      z-index: 10;\n    }\n\n    /* Glow - glows with customizable color (no movement) */\n    .mosaic-tile.hover-glow {\n      transition: box-shadow var(--hover-duration, 200ms) ease-out, filter var(--hover-duration, 200ms) ease-out;\n    }\n    .mosaic-tile.hover-glow:hover {\n      filter: brightness(1.2) saturate(1.2);\n      box-shadow: 0 0 20px var(--hover-color, rgba(255,255,255,0.6)), 0 0 40px var(--hover-color, rgba(255,255,255,0.3));\n      z-index: 10;\n    }\n\n    /* Zoom - dramatic scale with shadow */\n    .mosaic-tile.hover-zoom {\n      transition: transform var(--hover-duration, 200ms) cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow var(--hover-duration, 200ms) ease-out;\n    }\n    .mosaic-tile.hover-zoom:hover {\n      transform: scale(var(--hover-scale, 1.15));\n      box-shadow: 0 10px 40px rgba(0,0,0,0.3);\n      z-index: 10;\n    }\n\n    /* Tilt - dynamic 3D tilt based on mouse position (JS sets --tilt-x, --tilt-y) */\n    .mosaic-tile.hover-tilt {\n      transition: transform var(--hover-duration, 200ms) ease-out;\n      transform-style: preserve-3d;\n    }\n    .mosaic-tile.hover-tilt:hover {\n      transform: perspective(600px) rotateX(var(--tilt-x, 0deg)) rotateY(var(--tilt-y, 0deg)) scale(1.05);\n      z-index: 10;\n    }\n\n    /* Flip - 3D flip on hover */\n    @keyframes mosaic-hover-flip {\n      0% { transform: perspective(600px) rotateY(0deg); }\n      100% { transform: perspective(600px) rotateY(180deg); }\n    }\n    .mosaic-tile.hover-flip {\n      transition: transform var(--hover-duration, 300ms) ease-in-out;\n      transform-style: preserve-3d;\n    }\n    .mosaic-tile.hover-flip:hover {\n      transform: perspective(600px) rotateY(180deg) scale(1.05);\n      z-index: 10;\n    }\n\n    /* Blur - glassmorphism blur effect */\n    .mosaic-tile.hover-blur {\n      transition: filter var(--hover-duration, 200ms) ease-out, transform var(--hover-duration, 200ms) ease-out;\n    }\n    .mosaic-tile.hover-blur:hover {\n      filter: blur(0px) brightness(1.1);\n      transform: scale(1.08);\n      z-index: 10;\n    }\n    .mosaic-tile.hover-blur:not(:hover) {\n      filter: blur(1px) brightness(0.9);\n    }\n\n    /* Pop - bouncy scale animation */\n    @keyframes mosaic-pop {\n      0% { transform: scale(1); }\n      50% { transform: scale(1.15); }\n      100% { transform: scale(1.08); }\n    }\n    .mosaic-tile.hover-pop {\n      transition: transform var(--hover-duration, 200ms) ease-out;\n    }\n    .mosaic-tile.hover-pop:hover {\n      animation: mosaic-pop 0.3s ease-out forwards;\n      box-shadow: 0 8px 25px rgba(0,0,0,0.25);\n      z-index: 10;\n    }\n\n    /* Spotlight - subtle darkening, brighten on hover */\n    .mosaic-tile.hover-spotlight {\n      transition: filter var(--hover-duration, 200ms) ease-out, transform var(--hover-duration, 200ms) ease-out;\n      filter: brightness(0.7);\n    }\n    .mosaic-tile.hover-spotlight:hover {\n      filter: brightness(1.1) contrast(1.1);\n      transform: scale(1.05);\n      z-index: 10;\n    }\n\n    /* ========== DRAGGABLE STYLES ========== */\n    .mosaic-tile.draggable {\n      cursor: grab;\n    }\n    .mosaic-tile.draggable:active {\n      cursor: grabbing;\n    }\n    .mosaic-tile.dragging {\n      z-index: 100;\n      cursor: grabbing;\n      transition: none !important;\n    }\n  `;\n\n  document.head.appendChild(styleElement);\n}\n\n/**\n * Remove injected styles (only when all instances are destroyed)\n * Uses reference counting to support multiple Mosaic instances\n */\nexport function removeStyles(): void {\n  instanceCount--;\n  if (instanceCount <= 0 && styleElement) {\n    styleElement.remove();\n    styleElement = null;\n    instanceCount = 0; // Reset to prevent negative counts\n  }\n}\n","import type {\n  MosaicConfig,\n  ResolvedConfig,\n  TileData,\n  Pattern,\n  DelayCalculator,\n  PatternType,\n  AnimationType,\n  DelayMode,\n  HoverEffect,\n} from './types';\nimport {\n  resolveTarget,\n  createElement,\n  applyStyles,\n  clearElement,\n  preloadImage,\n  getElementDimensions,\n  debounce,\n  nextFrame,\n} from './utils/dom';\nimport { densityToGrid } from './utils/density';\nimport { shuffleArray } from './utils/math';\nimport { getPattern } from './patterns';\nimport { getDelayCalculator } from './delays';\nimport { applyHoverEffect, removeHoverEffect } from './interactions/hover';\nimport { initDraggable, destroyDraggable } from './interactions/drag';\nimport { injectStyles, removeStyles } from './styles';\n\n/**\n * Allowed CSS easing values (prevents CSS injection)\n */\nconst ALLOWED_EASINGS = [\n  'ease',\n  'ease-in',\n  'ease-out',\n  'ease-in-out',\n  'linear',\n] as const;\n\n/**\n * Validate easing value against whitelist\n */\nfunction validateEasing(easing: string): string {\n  if (ALLOWED_EASINGS.includes(easing as (typeof ALLOWED_EASINGS)[number])) {\n    return easing;\n  }\n  // Also allow cubic-bezier with validated format\n  const cubicBezierRegex = /^cubic-bezier\\(\\s*([0-9.]+)\\s*,\\s*([0-9.-]+)\\s*,\\s*([0-9.]+)\\s*,\\s*([0-9.-]+)\\s*\\)$/;\n  if (cubicBezierRegex.test(easing)) {\n    return easing;\n  }\n  // Default to safe value\n  return 'ease-out';\n}\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Partial<MosaicConfig> = {\n  renderAs: 'element',\n  width: 'auto',\n  height: 'auto',\n  pattern: 'grid',\n  density: 50,\n  maxTiles: 2500,\n  gap: 2,\n  borderRadius: 0,\n  animation: {\n    type: 'none',\n    duration: 500,\n    delay: 'sequential',\n    easing: 'ease-out',\n  },\n  hover: {\n    effect: 'none',\n    scale: 1.1,\n    duration: 200,\n  },\n  draggable: false,\n  shuffle: false,\n};\n\n/**\n * Main Mosaic class\n * Transforms an image into an interactive mosaic of tiles\n */\nexport class Mosaic {\n  private config: ResolvedConfig;\n  private container: HTMLElement | null = null;\n  private tiles: TileData[] = [];\n  private pattern: Pattern;\n  private delayCalculator: DelayCalculator;\n  private imageLoaded = false;\n  private imageDimensions: { width: number; height: number } = { width: 0, height: 0 };\n  private resizeObserver: ResizeObserver | null = null;\n  private originalTilePositions: Map<number, { x: number; y: number }> = new Map();\n  private lastContainerSize: { width: number; height: number } = { width: 0, height: 0 };\n  private tileClickHandlers: Map<HTMLElement, () => void> = new Map();\n\n  constructor(config: MosaicConfig) {\n    this.config = this.resolveConfig(config);\n    this.pattern = getPattern(this.config.pattern);\n    this.delayCalculator = getDelayCalculator(this.config.animation.delay);\n  }\n\n  /**\n   * Resolve and merge configuration with defaults\n   */\n  private resolveConfig(config: MosaicConfig): ResolvedConfig {\n    const target = resolveTarget(config.target);\n\n    const animation = {\n      type: config.animation?.type ?? DEFAULT_CONFIG.animation!.type!,\n      duration: config.animation?.duration ?? DEFAULT_CONFIG.animation!.duration!,\n      delay: config.animation?.delay ?? DEFAULT_CONFIG.animation!.delay!,\n      easing: config.animation?.easing ?? DEFAULT_CONFIG.animation!.easing!,\n    };\n\n    const hover = {\n      effect: config.hover?.effect ?? DEFAULT_CONFIG.hover!.effect!,\n      scale: config.hover?.scale ?? DEFAULT_CONFIG.hover!.scale!,\n      duration: config.hover?.duration ?? DEFAULT_CONFIG.hover!.duration!,\n      color: config.hover?.color,\n    };\n\n    // Normalize borderRadius to string\n    const borderRadiusValue = config.borderRadius ?? DEFAULT_CONFIG.borderRadius!;\n    const borderRadius = typeof borderRadiusValue === 'number'\n      ? `${borderRadiusValue}px`\n      : borderRadiusValue;\n\n    return {\n      target,\n      image: config.image,\n      renderAs: config.renderAs ?? DEFAULT_CONFIG.renderAs!,\n      width: config.width ?? DEFAULT_CONFIG.width!,\n      height: config.height ?? DEFAULT_CONFIG.height!,\n      pattern: config.pattern ?? DEFAULT_CONFIG.pattern!,\n      density: config.density ?? DEFAULT_CONFIG.density!,\n      maxTiles: config.maxTiles ?? DEFAULT_CONFIG.maxTiles!,\n      gap: config.gap ?? DEFAULT_CONFIG.gap!,\n      borderRadius,\n      animation,\n      hover,\n      draggable: config.draggable ?? DEFAULT_CONFIG.draggable!,\n      shuffle: config.shuffle ?? DEFAULT_CONFIG.shuffle!,\n      onReady: config.onReady,\n      onTileClick: config.onTileClick,\n      onError: config.onError,\n    };\n  }\n\n  /**\n   * Render the mosaic\n   */\n  async render(): Promise<void> {\n    // Inject CSS styles (only once)\n    injectStyles();\n\n    // Cleanup old interactivity before re-render\n    if (this.container) {\n      destroyDraggable(this.container);\n      this.tiles.forEach((tile) => {\n        if (tile.element) {\n          removeHoverEffect(tile.element);\n        }\n      });\n    }\n\n    // Disconnect old resize observer\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    // Preload image to get dimensions\n    if (!this.imageLoaded) {\n      try {\n        this.imageDimensions = await preloadImage(this.config.image);\n        this.imageLoaded = true;\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error('Failed to load image');\n        this.config.onError?.(err);\n        throw err;\n      }\n    }\n\n    // Get container dimensions\n    const containerDimensions = this.getContainerDimensions();\n\n    // Store dimensions to prevent resize loops\n    this.lastContainerSize = { ...containerDimensions };\n\n    // Create mosaic container\n    this.createContainer(containerDimensions);\n\n    // Generate tiles based on pattern\n    const gridDimensions = densityToGrid(\n      this.config.density,\n      containerDimensions.width,\n      containerDimensions.height,\n      this.config.maxTiles,\n      this.config.gap\n    );\n\n    this.tiles = this.pattern.generateTiles(\n      containerDimensions.width,\n      containerDimensions.height,\n      gridDimensions.cols,\n      gridDimensions.rows,\n      this.config.gap\n    );\n\n    // Store original positions for reset\n    this.tiles.forEach((tile) => {\n      this.originalTilePositions.set(tile.index, { x: tile.x, y: tile.y });\n    });\n\n    // Calculate animation delays\n    this.calculateDelays(gridDimensions.cols, gridDimensions.rows);\n\n    // Shuffle if configured\n    if (this.config.shuffle) {\n      this.shuffleTilePositions();\n    }\n\n    // Render tiles\n    await this.renderTiles(gridDimensions.cols, gridDimensions.rows);\n\n    // Setup interactivity\n    this.setupInteractivity();\n\n    // Setup resize observer\n    this.setupResizeObserver();\n\n    // Trigger onReady callback\n    this.config.onReady?.();\n  }\n\n  /**\n   * Get container dimensions\n   */\n  private getContainerDimensions(): { width: number; height: number } {\n    let width: number;\n    let height: number;\n\n    if (this.config.width === 'auto' || this.config.height === 'auto') {\n      const dims = getElementDimensions(this.config.target);\n      width = this.config.width === 'auto' ? dims.width : this.config.width;\n      height = this.config.height === 'auto' ? dims.height : this.config.height;\n\n      // If height is still 0, use image aspect ratio\n      if (height === 0 && this.imageDimensions.height > 0) {\n        height = (width / this.imageDimensions.width) * this.imageDimensions.height;\n      }\n    } else {\n      width = this.config.width;\n      height = this.config.height;\n    }\n\n    return { width, height };\n  }\n\n  /**\n   * Create the mosaic container element\n   */\n  private createContainer(dimensions: { width: number; height: number }): void {\n    clearElement(this.config.target);\n\n    this.container = createElement(\n      'div',\n      {\n        ...this.pattern.getContainerStyles(),\n        width: `${dimensions.width}px`,\n        height: `${dimensions.height}px`,\n      },\n      'mosaic-container'\n    );\n\n    this.config.target.appendChild(this.container);\n  }\n\n  /**\n   * Calculate animation delays for each tile\n   */\n  private calculateDelays(cols: number, rows: number): void {\n    const maxDelay = this.config.animation.duration * 2;\n    const totalTiles = this.tiles.length;\n\n    this.tiles.forEach((tile) => {\n      tile.animationDelay = this.delayCalculator.calculate(\n        tile,\n        totalTiles,\n        cols,\n        rows,\n        maxDelay\n      );\n    });\n  }\n\n  /**\n   * Shuffle tile visual positions (not the background)\n   */\n  private shuffleTilePositions(): void {\n    const positions = this.tiles.map((tile) => ({ x: tile.x, y: tile.y }));\n    const shuffledPositions = shuffleArray(positions);\n\n    this.tiles.forEach((tile, index) => {\n      tile.x = shuffledPositions[index].x;\n      tile.y = shuffledPositions[index].y;\n    });\n  }\n\n  /**\n   * Render all tiles to the container\n   */\n  private async renderTiles(cols: number, rows: number): Promise<void> {\n    if (!this.container) return;\n\n    // Use DocumentFragment for batched DOM insertion (better performance)\n    const fragment = document.createDocumentFragment();\n\n    // Create all tile elements with initial (hidden) state\n    for (const tile of this.tiles) {\n      const element = this.createTileElement(tile, cols, rows);\n      tile.element = element;\n      fragment.appendChild(element);\n    }\n\n    // Single DOM insertion for all tiles\n    this.container.appendChild(fragment);\n\n    // Wait for next frame to ensure elements are in DOM\n    await nextFrame();\n\n    // Animate tiles in\n    for (const tile of this.tiles) {\n      if (tile.element) {\n        this.animateTileIn(tile);\n      }\n    }\n  }\n\n  /**\n   * Create a single tile element\n   */\n  private createTileElement(tile: TileData, cols: number, rows: number): HTMLElement {\n    const tileStyles = this.pattern.getTileStyles(tile, this.config.image, cols, rows);\n\n    // Apply borderRadius only for patterns without clip-path\n    const borderRadiusStyle: Record<string, string> = !tile.clipPath && this.config.borderRadius !== '0px'\n      ? { 'border-radius': this.config.borderRadius }\n      : {};\n\n    const element = createElement(\n      'div',\n      {\n        ...tileStyles,\n        ...borderRadiusStyle,\n        cursor: this.config.onTileClick || this.config.draggable ? 'pointer' : 'default',\n      },\n      'mosaic-tile'\n    );\n\n    // Set CSS custom properties for animation timing\n    element.style.setProperty('--animation-duration', `${this.config.animation.duration}ms`);\n    element.style.setProperty('--animation-delay', `${tile.animationDelay}ms`);\n    element.style.setProperty('--animation-easing', validateEasing(this.config.animation.easing));\n\n    // Set random values for scatter animation\n    if (this.config.animation.type === 'scatter') {\n      element.style.setProperty('--random-x', String(Math.random()));\n      element.style.setProperty('--random-y', String(Math.random()));\n      element.style.setProperty('--random-r', String(Math.random()));\n    }\n\n    // Add animation class\n    const animationType = this.config.animation.type;\n    element.classList.add(`animate-${animationType}`);\n\n    // When animation completes, swap to 'complete' class to remove transform\n    // This allows hover transforms to work without conflict\n    if (animationType !== 'none') {\n      element.addEventListener('animationend', () => {\n        element.classList.remove(`animate-${animationType}`);\n        element.classList.add('animate-complete');\n      }, { once: true });\n    }\n\n    element.dataset.index = String(tile.index);\n    element.dataset.row = String(tile.row);\n    element.dataset.col = String(tile.col);\n\n    // Add click handler (store reference for cleanup)\n    if (this.config.onTileClick) {\n      const handler = () => this.config.onTileClick?.(tile, tile.index);\n      element.addEventListener('click', handler);\n      this.tileClickHandlers.set(element, handler);\n    }\n\n    return element;\n  }\n\n  /**\n   * Animate a tile into view\n   * With CSS-only animations, the animation class already handles this\n   * The element is created with the animation class which triggers automatically\n   */\n  private animateTileIn(_tile: TileData): void {\n    // CSS animations with 'forwards' fill mode handle the final state automatically\n    // No JavaScript manipulation needed\n  }\n\n  /**\n   * Setup hover and drag interactivity\n   */\n  private setupInteractivity(): void {\n    // Setup hover effects\n    if (this.config.hover.effect !== 'none') {\n      this.tiles.forEach((tile) => {\n        if (tile.element) {\n          applyHoverEffect(tile.element, this.config.hover);\n        }\n      });\n    }\n\n    // Setup draggable\n    if (this.config.draggable && this.container) {\n      initDraggable(this.container, this.tiles);\n    }\n  }\n\n  /**\n   * Setup resize observer for responsive behavior\n   */\n  private setupResizeObserver(): void {\n    // Feature detection: ResizeObserver not available in older browsers (IE11, Safari <13.1)\n    if (typeof ResizeObserver === 'undefined') {\n      return; // Graceful fallback - no auto-resize on unsupported browsers\n    }\n\n    const debouncedResize = debounce(() => {\n      // Check if size actually changed to prevent render loops\n      const currentSize = getElementDimensions(this.config.target);\n      if (\n        currentSize.width === this.lastContainerSize.width &&\n        currentSize.height === this.lastContainerSize.height\n      ) {\n        return; // Size hasn't changed, skip re-render\n      }\n      this.render();\n    }, 250);\n\n    this.resizeObserver = new ResizeObserver(debouncedResize);\n    this.resizeObserver.observe(this.config.target);\n  }\n\n  /**\n   * Shuffle tiles to random positions\n   */\n  shuffle(): void {\n    this.shuffleTilePositions();\n\n    this.tiles.forEach((tile) => {\n      if (tile.element) {\n        applyStyles(tile.element, {\n          left: `${tile.x}px`,\n          top: `${tile.y}px`,\n        });\n      }\n    });\n  }\n\n  /**\n   * Reset tiles to original positions\n   */\n  reset(): void {\n    this.tiles.forEach((tile) => {\n      const original = this.originalTilePositions.get(tile.index);\n      if (original && tile.element) {\n        tile.x = original.x;\n        tile.y = original.y;\n        applyStyles(tile.element, {\n          left: `${tile.x}px`,\n          top: `${tile.y}px`,\n        });\n      }\n    });\n  }\n\n  /**\n   * Update the image\n   */\n  async setImage(src: string): Promise<void> {\n    this.config.image = src;\n    this.imageLoaded = false;\n    await this.render();\n  }\n\n  /**\n   * Update density\n   */\n  async setDensity(density: number): Promise<void> {\n    this.config.density = Math.max(1, Math.min(100, density));\n    await this.render();\n  }\n\n  /**\n   * Update pattern\n   */\n  async setPattern(pattern: PatternType): Promise<void> {\n    this.config.pattern = pattern;\n    this.pattern = getPattern(pattern);\n    await this.render();\n  }\n\n  /**\n   * Update animation type\n   * Note: Requires re-render to apply new animation class to tiles\n   */\n  async setAnimation(type: AnimationType): Promise<void> {\n    this.config.animation.type = type;\n    await this.render();\n  }\n\n  /**\n   * Update delay mode\n   */\n  setDelayMode(delay: DelayMode): void {\n    this.config.animation.delay = delay;\n    this.delayCalculator = getDelayCalculator(delay);\n  }\n\n  /**\n   * Update hover effect\n   */\n  setHoverEffect(effect: HoverEffect): void {\n    // Remove old effects\n    this.tiles.forEach((tile) => {\n      if (tile.element) {\n        removeHoverEffect(tile.element);\n      }\n    });\n\n    this.config.hover.effect = effect;\n\n    // Apply new effects\n    if (effect !== 'none') {\n      this.tiles.forEach((tile) => {\n        if (tile.element) {\n          applyHoverEffect(tile.element, this.config.hover);\n        }\n      });\n    }\n  }\n\n  /**\n   * Update configuration\n   */\n  async updateConfig(config: Partial<MosaicConfig>): Promise<void> {\n    this.config = this.resolveConfig({ ...this.config, ...config });\n\n    if (config.pattern) {\n      this.pattern = getPattern(this.config.pattern);\n    }\n    if (config.animation?.delay) {\n      this.delayCalculator = getDelayCalculator(this.config.animation.delay);\n    }\n\n    await this.render();\n  }\n\n  /**\n   * Get current tiles\n   */\n  getTiles(): TileData[] {\n    return [...this.tiles];\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): ResolvedConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Destroy the mosaic and cleanup\n   */\n  destroy(): void {\n    // Remove resize observer\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    // Cleanup draggable\n    if (this.container) {\n      destroyDraggable(this.container);\n    }\n\n    // Remove click handlers\n    this.tileClickHandlers.forEach((handler, element) => {\n      element.removeEventListener('click', handler);\n    });\n    this.tileClickHandlers.clear();\n\n    // Remove hover effects\n    this.tiles.forEach((tile) => {\n      if (tile.element) {\n        removeHoverEffect(tile.element);\n      }\n    });\n\n    // Clear container\n    clearElement(this.config.target);\n\n    // Reset state\n    this.container = null;\n    this.tiles = [];\n    this.originalTilePositions.clear();\n\n    // Remove shared styles (only when all instances destroyed)\n    removeStyles();\n  }\n}\n","import { Mosaic } from './mosaic';\nimport type { PatternType, AnimationType, DelayMode, HoverEffect } from './types';\n\n/**\n * MosaicImage Web Component\n * Usage: <mosaic-image src=\"image.jpg\" pattern=\"grid\" density=\"50\"></mosaic-image>\n */\nexport class MosaicImageElement extends HTMLElement {\n  private mosaic: Mosaic | null = null;\n  private container: HTMLDivElement;\n\n  static get observedAttributes(): string[] {\n    return [\n      'src',\n      'pattern',\n      'density',\n      'gap',\n      'animation',\n      'animation-duration',\n      'animation-delay',\n      'hover',\n      'draggable',\n      'width',\n      'height',\n    ];\n  }\n\n  constructor() {\n    super();\n\n    // Create shadow DOM\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // Add styles\n    const style = document.createElement('style');\n    style.textContent = `\n      :host {\n        display: block;\n        position: relative;\n      }\n      .mosaic-wrapper {\n        width: 100%;\n        height: 100%;\n      }\n    `;\n    shadow.appendChild(style);\n\n    // Create container\n    this.container = document.createElement('div');\n    this.container.className = 'mosaic-wrapper';\n    shadow.appendChild(this.container);\n  }\n\n  connectedCallback(): void {\n    this.initMosaic();\n  }\n\n  disconnectedCallback(): void {\n    this.mosaic?.destroy();\n    this.mosaic = null;\n  }\n\n  attributeChangedCallback(_name: string, oldValue: string, newValue: string): void {\n    if (oldValue === newValue) return;\n\n    if (this.mosaic) {\n      this.updateMosaicFromAttributes();\n    }\n  }\n\n  private async initMosaic(): Promise<void> {\n    const src = this.getAttribute('src');\n    if (!src) {\n      const error = new Error('MosaicImage: src attribute is required');\n      this.dispatchEvent(new CustomEvent('error', { detail: error }));\n      return;\n    }\n\n    const config = this.getConfigFromAttributes();\n\n    try {\n      this.mosaic = new Mosaic({\n        target: this.container,\n        image: src,\n        ...config,\n        onError: (error) => {\n          this.dispatchEvent(new CustomEvent('error', { detail: error }));\n        },\n      });\n\n      await this.mosaic.render();\n      this.dispatchEvent(new CustomEvent('ready'));\n    } catch (error) {\n      this.dispatchEvent(new CustomEvent('error', { detail: error }));\n    }\n  }\n\n  private getConfigFromAttributes(): Record<string, unknown> {\n    const config: Record<string, unknown> = {};\n\n    // Pattern\n    const pattern = this.getAttribute('pattern');\n    if (pattern) {\n      config.pattern = pattern as PatternType;\n    }\n\n    // Density\n    const density = this.getAttribute('density');\n    if (density) {\n      config.density = parseInt(density, 10);\n    }\n\n    // Gap\n    const gap = this.getAttribute('gap');\n    if (gap) {\n      config.gap = parseInt(gap, 10);\n    }\n\n    // Dimensions\n    const width = this.getAttribute('width');\n    if (width) {\n      config.width = width === 'auto' ? 'auto' : parseInt(width, 10);\n    }\n\n    const height = this.getAttribute('height');\n    if (height) {\n      config.height = height === 'auto' ? 'auto' : parseInt(height, 10);\n    }\n\n    // Animation\n    const animation = this.getAttribute('animation');\n    const animationDuration = this.getAttribute('animation-duration');\n    const animationDelay = this.getAttribute('animation-delay');\n\n    if (animation || animationDuration || animationDelay) {\n      config.animation = {\n        type: (animation as AnimationType) || 'fade',\n        duration: animationDuration ? parseInt(animationDuration, 10) : 500,\n        delay: this.parseDelayMode(animationDelay),\n      };\n    }\n\n    // Hover\n    const hover = this.getAttribute('hover');\n    if (hover) {\n      config.hover = {\n        effect: hover as HoverEffect,\n      };\n    }\n\n    // Draggable\n    const draggable = this.getAttribute('draggable');\n    if (draggable !== null) {\n      config.draggable = draggable !== 'false';\n    }\n\n    return config;\n  }\n\n  private parseDelayMode(value: string | null): DelayMode {\n    if (!value) return 'random';\n    const num = parseInt(value, 10);\n    if (!isNaN(num)) return num;\n    return value as DelayMode;\n  }\n\n  private async updateMosaicFromAttributes(): Promise<void> {\n    if (!this.mosaic) return;\n\n    try {\n      const src = this.getAttribute('src');\n      if (src) {\n        await this.mosaic.setImage(src);\n      }\n\n      const config = this.getConfigFromAttributes();\n      await this.mosaic.updateConfig(config);\n    } catch (error) {\n      this.dispatchEvent(new CustomEvent('error', { detail: error }));\n    }\n  }\n\n  // Public API methods\n\n  /**\n   * Shuffle the tiles\n   */\n  shuffle(): void {\n    this.mosaic?.shuffle();\n  }\n\n  /**\n   * Reset tiles to original positions\n   */\n  reset(): void {\n    this.mosaic?.reset();\n  }\n\n  /**\n   * Re-render the mosaic\n   */\n  async render(): Promise<void> {\n    await this.mosaic?.render();\n  }\n\n  /**\n   * Get the underlying Mosaic instance\n   */\n  getMosaic(): Mosaic | null {\n    return this.mosaic;\n  }\n}\n\n/**\n * Register the custom element\n */\nexport function registerMosaicElement(tagName = 'mosaic-image'): void {\n  if (!customElements.get(tagName)) {\n    customElements.define(tagName, MosaicImageElement);\n  }\n}\n","import type { Animation, AnimationType } from '../types';\n\n/**\n * Fade animation - tiles fade in from transparent\n */\nexport class FadeAnimation implements Animation {\n  name: AnimationType = 'fade';\n\n  getInitialStyles(): Record<string, string> {\n    return {\n      opacity: '0',\n    };\n  }\n\n  getFinalStyles(): Record<string, string> {\n    return {\n      opacity: '1',\n    };\n  }\n\n  getTransition(duration: number, easing: string): string {\n    return `opacity ${duration}ms ${easing}`;\n  }\n}\n","import type { Animation, AnimationType } from '../types';\n\n/**\n * Scale animation - tiles scale up from zero\n */\nexport class ScaleAnimation implements Animation {\n  name: AnimationType = 'scale';\n\n  getInitialStyles(): Record<string, string> {\n    return {\n      opacity: '0',\n      transform: 'scale(0)',\n    };\n  }\n\n  getFinalStyles(): Record<string, string> {\n    return {\n      opacity: '1',\n      transform: 'scale(1)',\n    };\n  }\n\n  getTransition(duration: number, easing: string): string {\n    return `opacity ${duration}ms ${easing}, transform ${duration}ms ${easing}`;\n  }\n}\n","import type { Animation, AnimationType } from '../types';\n\n/**\n * Flip animation - tiles flip in with 3D rotation\n */\nexport class FlipAnimation implements Animation {\n  name: AnimationType = 'flip';\n\n  getInitialStyles(): Record<string, string> {\n    return {\n      opacity: '0',\n      transform: 'perspective(1000px) rotateY(90deg)',\n      'backface-visibility': 'hidden',\n    };\n  }\n\n  getFinalStyles(): Record<string, string> {\n    return {\n      opacity: '1',\n      transform: 'perspective(1000px) rotateY(0deg)',\n    };\n  }\n\n  getTransition(duration: number, easing: string): string {\n    return `opacity ${duration}ms ${easing}, transform ${duration}ms ${easing}`;\n  }\n}\n","import type { Animation, AnimationType } from '../types';\n\n/**\n * Slide animation - tiles slide in from edges\n */\nexport class SlideAnimation implements Animation {\n  name: AnimationType = 'slide';\n\n  getInitialStyles(): Record<string, string> {\n    return {\n      opacity: '0',\n      transform: 'translateY(50px)',\n    };\n  }\n\n  getFinalStyles(): Record<string, string> {\n    return {\n      opacity: '1',\n      transform: 'translateY(0)',\n    };\n  }\n\n  getTransition(duration: number, easing: string): string {\n    return `opacity ${duration}ms ${easing}, transform ${duration}ms ${easing}`;\n  }\n}\n","import type { Animation, AnimationType } from '../types';\n\n/**\n * Scatter animation - tiles scatter in from random positions\n */\nexport class ScatterAnimation implements Animation {\n  name: AnimationType = 'scatter';\n\n  getInitialStyles(): Record<string, string> {\n    // Random scatter direction\n    const angle = Math.random() * Math.PI * 2;\n    const distance = 100 + Math.random() * 200;\n    const x = Math.cos(angle) * distance;\n    const y = Math.sin(angle) * distance;\n    const rotation = (Math.random() - 0.5) * 360;\n\n    return {\n      opacity: '0',\n      transform: `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(0.5)`,\n    };\n  }\n\n  getFinalStyles(): Record<string, string> {\n    return {\n      opacity: '1',\n      transform: 'translate(0, 0) rotate(0deg) scale(1)',\n    };\n  }\n\n  getTransition(duration: number, easing: string): string {\n    return `opacity ${duration}ms ${easing}, transform ${duration}ms ${easing}`;\n  }\n}\n","import type { Animation, AnimationType } from '../types';\nimport { FadeAnimation } from './fade';\nimport { ScaleAnimation } from './scale';\nimport { FlipAnimation } from './flip';\nimport { SlideAnimation } from './slide';\nimport { ScatterAnimation } from './scatter';\n\n/**\n * No animation - immediate display\n */\nclass NoneAnimation implements Animation {\n  name: AnimationType = 'none';\n\n  getInitialStyles(): Record<string, string> {\n    return {\n      opacity: '1',\n    };\n  }\n\n  getFinalStyles(): Record<string, string> {\n    return {\n      opacity: '1',\n    };\n  }\n\n  getTransition(): string {\n    return 'none';\n  }\n}\n\n/**\n * Animation registry\n */\nconst animations: Map<AnimationType, Animation> = new Map([\n  ['fade', new FadeAnimation()],\n  ['scale', new ScaleAnimation()],\n  ['flip', new FlipAnimation()],\n  ['slide', new SlideAnimation()],\n  ['scatter', new ScatterAnimation()],\n  ['none', new NoneAnimation()],\n]);\n\n/**\n * Get an animation by name\n */\nexport function getAnimation(name: AnimationType): Animation {\n  const animation = animations.get(name);\n  if (!animation) {\n    console.warn(`Animation \"${name}\" not found, falling back to fade`);\n    return animations.get('fade')!;\n  }\n  return animation;\n}\n\n/**\n * Get all available animation names\n */\nexport function getAnimationNames(): AnimationType[] {\n  return Array.from(animations.keys());\n}\n\n/**\n * Register a custom animation\n */\nexport function registerAnimation(animation: Animation): void {\n  animations.set(animation.name, animation);\n}\n\n// Re-export animation classes\nexport { FadeAnimation } from './fade';\nexport { ScaleAnimation } from './scale';\nexport { FlipAnimation } from './flip';\nexport { SlideAnimation } from './slide';\nexport { ScatterAnimation } from './scatter';\n"],"names":["resolveTarget","target","element","createElement","tag","styles","className","applyStyles","property","value","clearElement","preloadImage","src","resolve","reject","img","getElementDimensions","rect","debounce","fn","delay","timeoutId","args","nextFrame","MIN_TILES","densityToGrid","density","containerWidth","containerHeight","maxTiles","gap","normalizedDensity","targetTiles","aspectRatio","cols","rows","totalGapWidth","totalGapHeight","tileWidth","tileHeight","columnsToApproxDensity","normalizedTiles","distance","x1","y1","x2","y2","gridCenter","shuffleArray","array","result","i","j","spiralOrder","matrix","r","c","centerRow","centerCol","visited","directions","dirIndex","steps","stepsTaken","turnsAtCurrentSteps","key","BasePattern","__publicField","url","tile","imageUrl","_cols","_rows","col","row","bgPosX","bgPosY","GridPattern","tiles","index","x","y","BrickPattern","offset","isOddRow","tilesInRow","width","DiamondPattern","StripsPattern","orientation","count","stripHeight","stripWidth","VoronoiPattern","numPoints","points","cellWidth","cellHeight","jitterX","jitterY","point","polygon","xs","p","ys","minX","maxX","minY","maxY","height","clipPoints","center","allPoints","other","midX","midY","dx","dy","lineX","lineY","normalX","normalY","len","nx","ny","offsetLineX","offsetLineY","current","next","currentSide","nextSide","intersection","p1","p2","denom","t","PuzzlePattern","baseTileWidth","baseTileHeight","baseX","baseY","edges","expandedX","expandedY","expandedWidth","expandedHeight","clipPath","tabSize","inset","left","top","right","bottom","pathParts","effectiveTabSize","startX","startY","endX","endY","edgeType","outwardDir","direction","tabWidth","tabDepth","sign","neckStart","neckEnd","perpSign","peakY","neckY","peakX","neckX","dir","patterns","getPattern","name","pattern","getPatternNames","registerPattern","SequentialDelay","totalTiles","maxDelay","RandomDelay","_tile","_totalTiles","CenterDelay","dist","maxDist","SpiralDelay","cacheKey","order","spiralIndex","FixedDelay","delayCalculators","getDelayCalculator","mode","calculator","getDelayModeNames","registerDelayCalculator","tiltHandlers","applyHoverEffect","config","effect","scale","duration","color","setupTiltTracking","handleMouseMove","e","centerX","centerY","tiltY","tiltX","handleMouseLeave","removeHoverEffect","handlers","dragStates","dragHandlers","initDraggable","container","state","startDrag","clientX","clientY","moveDrag","newX","newY","endDrag","dropTarget","findClosestTile","swapTiles","touch","dragged","closest","minDist","dragCenterX","dragCenterY","tileCenterX","tileCenterY","threshold","tile1","tile2","tile1OriginalX","tile1OriginalY","tile2X","tile2Y","destroyDraggable","styleElement","instanceCount","injectStyles","removeStyles","ALLOWED_EASINGS","validateEasing","easing","DEFAULT_CONFIG","Mosaic","_a","_b","_c","_d","_e","_f","_g","_h","animation","hover","borderRadiusValue","borderRadius","error","err","containerDimensions","gridDimensions","dims","dimensions","positions","shuffledPositions","fragment","tileStyles","borderRadiusStyle","animationType","handler","debouncedResize","currentSize","original","type","MosaicImageElement","shadow","style","_name","oldValue","newValue","animationDuration","animationDelay","draggable","num","registerMosaicElement","tagName","FadeAnimation","ScaleAnimation","FlipAnimation","SlideAnimation","ScatterAnimation","angle","rotation","NoneAnimation","animations","getAnimation","getAnimationNames","registerAnimation"],"mappings":"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"}